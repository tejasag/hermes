"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const readline = require("readline");
const option_parser_1 = require("./option-parser");
const help_gen_1 = require("./help-gen");
const command_parser_1 = require("./command-parser");
const parameter_parser_1 = require("./parameter-parser");
const helpers_1 = require("./helpers");
class CLI {
    constructor(opts = {}) {
        this.cmds = {};
        this.delimiter = "$> ";
        this.isActive = false;
        const input = opts.input || process.stdin;
        const output = opts.output || process.stdout;
        this.readline = readline.createInterface(input, output);
        this.readline.pause();
    }
    paramIsRequired(param) {
        if (typeof param === "string")
            return true;
        return !param.optional && !param.rest;
    }
    isRestParameter(param) {
        return !(typeof param === "string") && param.rest;
    }
    checkCommandForErrors(command) {
        if (command instanceof Function)
            return;
        if (!command.parameters)
            return;
        let hasHadOptional = false;
        command.parameters.forEach((param, index, parameters) => {
            const isRequired = this.paramIsRequired(param);
            if (isRequired && hasHadOptional) {
                throw new Error(`Invalid parameter order. Required parameter after optional.`);
            }
            if (!isRequired)
                hasHadOptional = true;
            if (this.isRestParameter(param) && (index + 1) !== parameters.length) {
                throw new Error(`Rest parameter be last`);
            }
        });
    }
    executeCommand(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const parts = input.match(/(\w|@|-|\.)+|"[^"]+"|'[^']+'/g) || [];
            const pieces = parts.map(word => word.replace(/^"(.+(?="$))"$/, '$1')).
                map(word => word.replace(/^'(.+(?='$))'$/, '$1'));
            if (pieces[0] === "help")
                return this.help(pieces.slice(1));
            const parsedCmd = command_parser_1.findPromptedCommand(pieces, this.cmds);
            if (!parsedCmd)
                return this.invalidCommand();
            const options = option_parser_1.parseOptions(parsedCmd.command, parsedCmd.remainingPieces);
            if (!options)
                return this.help(pieces);
            const params = parameter_parser_1.parseParameters(parsedCmd.command, options.remainingPieces);
            if (!params)
                return this.help(pieces);
            return parsedCmd.command.action(params, options.options);
        });
    }
    invalidCommand() {
        console.log(`Invalid Command`);
        this.help([]);
    }
    prompt() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => {
                this.readline.question(this.delimiter, resolve);
            });
        });
    }
    startREPL() {
        return __awaiter(this, void 0, void 0, function* () {
            while (this.isActive) {
                const input = yield this.prompt();
                yield this.executeCommand(input).catch(e => console.log(e));
            }
        });
    }
    help(commandPieces) {
        if (commandPieces.length === 0) {
            help_gen_1.printOverviewHelp({
                info: this.info, name: this.name, version: this.version, commands: this.cmds
            });
            return;
        }
        const commandOpts = command_parser_1.findPromptedCommand(commandPieces, this.cmds);
        if (!commandOpts)
            return this.help([]);
        help_gen_1.printCommandHelp(commandPieces.slice(0, commandPieces.length - commandOpts.remainingPieces.length).join(" "), commandOpts.command);
    }
    removeCommandAliases(commandName) {
        const command = this.cmds[commandName];
        if (!command || command instanceof Function || !command.aliases)
            return;
        command.aliases.forEach(alias => delete this.cmds[alias]);
    }
    /** Set the cli delimiter */
    setDelimiter(delimiter) {
        this.delimiter = delimiter;
        return this;
    }
    addCommand(name, command) {
        this.checkCommandForErrors(command);
        this.cmds[name] = command;
        helpers_1.registerCommandAliases({ name, command, commands: this.cmds });
        return this;
    }
    /** Register multiple commands at once (Alias for registerCommands) */
    addCommands(commands) {
        for (const command in commands) {
            this.addCommand(command, commands[command]);
        }
        return this;
    }
    removeCommand(command) {
        this.removeCommandAliases(command);
        delete this.cmds[command];
        return this;
    }
    /** Show the CLI */
    show() {
        this.readline.resume();
        this.isActive = true;
        this.startREPL();
        return this;
    }
    /** Hide the cli */
    hide() {
        this.readline.pause();
        this.isActive = false;
        return this;
    }
    /** Show the help menu */
    showHelp() {
        this.help([]);
        return this;
    }
    setVersion(val) {
        this.version = val;
        return this;
    }
    setInfo(val) {
        this.info = val;
        return this;
    }
    setName(val) {
        this.name = val;
        return this;
    }
    hasCommand(cmd) {
        return !!this.cmds[cmd];
    }
    /**
     * Register a command.
     *
     * @deprecated - Use addCommand instead.
     */
    command(name, opts) {
        console.warn("command is deprecated - use addCommand instead");
        return this.addCommand(name, opts);
    }
    /**
     * Register multiple commands at once (Alias for registerCommands).
     *
     * @deprecated - Use addCommands instead.
     **/
    commands(name) {
        console.warn("commands is deprecated - use addCommands instead");
        return this.addCommands(name);
    }
    /**
     * Register multiple commands at once (Alias for registerCommands).
     *
     * @deprecated - Use addCommands instead.
     **/
    registerCommands(name) {
        console.warn("registerCommands is deprecated - use addCommands instead");
        return this.registerCommands(name);
    }
}
exports.CLI = CLI;
//# sourceMappingURL=index.js.map